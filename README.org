#+TITLE: ghelp

This package provides a generic help system similar to Emacs Help. Unlike Emacs Help, ghelp works for more major-modes and is extensible with backends.

[[https://github.com/casouri/ghelp#screencasts][☞ Screencasts]]

Currently supported backends:
- [[https://github.com/Wilfred/helpful][helpful]]
- [[https://github.com/joaotavora/eglot][eglot]]

* Install & load

Download the files and add them to load path.

With ~use-package~:
#+BEGIN_SRC emacs-lisp
(use-package ghelp
  :config (ghelp-global-minor-mode))
#+END_SRC
Without ~use-package~:
#+BEGIN_SRC emacs-lisp
(require 'ghelp)
(ghelp-global-minor-mode)
#+END_SRC

* Usage
Currently you can bind ~ghelp-describe~ and ~ghelp-describe-at-point~ to a keybinding you like, or bind ~ghelp-map~. To resume to a previous opened page (like ~helm-resume~), use ~ghelp-resume~.

To access Emacs Lisp help regardless of your current major mode, use ~ghelp-describe-as-in-emacs-lisp-mode~.

* In ghelp buffer
A ghelp buffer is called a page. Each page is made of several entries. Each entry is a self-contained documentation. (For example, you could have a entry for a symbol as a function and another one for it as a variable.)

Commands you can use:

| Key           | Command                        |
|---------------+--------------------------------|
| =f/b=         | go forward/backward in history |
| =n/p=         | next/previous entry            |
| =m/[=         | next/previous button           |
| =TAB=         | collapse/expand entry          |
| =g=           | refresh page                   |
| =q=           | close page                     |
| =<space>=     | scroll down                    |
| =<backspace>= | scroll up                      |
| =s=           | search/switch to a page        |

* Customization
If you want several major modes to share the same set of history and backends (like ~lisp-interaction-mode~ and ~emacs-lisp-mode~), add an entry ~(mode1 . mode2)~ to ~ghelp-mode-share-alist~, and ~mode1~ will share everything of ~mode2~.

You can customize faces: ~ghelp-entry~, ~ghelp-folded-entry~, and ~ghelp-entry-title~.

Normally if you call ~ghelp-describe-function~ it selects the backends to use by the current major-mode. If you want to look up some symbol with a specific backend, try ~(ghelp-describe-as-in 'mode)~. This function returns a modified ~ghelp-describe-function~ that selects backends by ~mode~. For example, you can bind
#+BEGIN_SRC emacs-lisp
(define-key (kbd "C-h C-e") (ghelp-describe-as-in ’emacs-lisp-mode))
#+END_SRC
to look up Emacs symbols regardless of which major mode you are currently in.

* Write a backend
Each major mode is tied to one backend. Each backend is a function that does all the work: get a symbol, find the documentation and return them.

Below is an example backend that gets symbol and documentation and returns them.
#+BEGIN_SRC emacs-lisp
(defun ghelp-dummy-backend (&optional no-prompt symbol)
  "Demo. No prompt if NO-PROMPT is non-nil.
If SYMBOL non-nil, just describe it, otherwise get a symbol by prompting or guessing."
  (let* ((default-symbol (symbol-at-point))
         (symbol (or symbol
                     ;; get symbol from user, I don’t have to make a prompt though
                     (if no-prompt
                         default-symbol
                       (ghelp-completing-read ; I can also use ‘completing-read’
                        default-symbol
                        '("woome" "veemo" "love" "and" "peace" "many")))))
         ;; just to demo a usage of ‘store’
         (ghelp-page-store-get 'my-var) ; = "cool"
         ;; get documentation
         (entry-list (pcase symbol
                       ;;           title   documentation
                       ("woome" '(("Woome"  "Woome!\n")))
                       ("veemo" '(("Veemo"  "Veemo!\n")))
                       ("love"  '(("Love"   "Love is good.\n")))
                       ("and"   '(("And"    "And is a conjunction.\n")))
                       ("peace" '(("Peace"  "もう大丈夫だ！なぜって？私が来た！\n")))
                       ;; multiple entries
                       ("many"  '(("Many1"  "I’m ONE.\n") ("Many2" "I’m TWO.\n"))))))
    ;; store some value for later use
    (list symbol entry-list `((my-var "cool")))))
#+END_SRC

Register your backend by
#+BEGIN_SRC emacs-lisp
(ghelp-register-backend 'major-mode #'your-backend-function)
#+END_SRC

* Screencasts
*Eglot*

[[./ghelp-eglot-800.gif]]

*Helpful*

[[./ghelp-helpful-800.gif]]
