#+TITLE: ghelp

This package provides a generic help system similar to Emacs Help. Unlike Emacs Help, ghelp works for more major-modes and is extensible with backends.

[[https://github.com/casouri/ghelp#screencasts][☞ Screencasts]]

Currently supported backends:
- [[https://github.com/Wilfred/helpful][helpful]]
- [[https://github.com/joaotavora/eglot][eglot]]
- [[https://www.nongnu.org/geiser/][geiser]]

* Install & load
Download the files and add them to load path.

With ~use-package~:
#+BEGIN_SRC emacs-lisp
(use-package ghelp)
#+END_SRC
Without ~use-package~:
#+BEGIN_SRC emacs-lisp
(require 'ghelp)
#+END_SRC

* Usage
Currently you can bind ~ghelp-describe~ and ~ghelp-describe-at-point~ to a keybinding you like, or bind ~ghelp-map~. To resume to a previous opened page (like ~helm-resume~), use ~ghelp-resume~.

To access Emacs Lisp help regardless of your current major mode, use ~ghelp-describe-as-in-emacs-lisp-mode~.

* In ghelp buffer
A ghelp buffer is called a page. Each page is made of several entries. Each entry is a self-contained documentation. (For example, you could have a entry for a symbol as a function and another one for it as a variable.)

Commands you can use:

| Key         | Command                        |
|-------------+--------------------------------|
| =f/b=         | go forward/backward in history |
| =n/p=         | next/previous line             |
| =N/P=         | next/previous entry            |
| =m/[=         | next/previous button           |
| =TAB=         | next button                    |
| =C-TAB=       | collapse/expand entry          |
| =g=           | refresh page                   |
| =q=           | close page                     |
| =<space>=     | scroll down                    |
| =<backspace>= | scroll up                      |
| =s=           | search/switch to a page        |

* Customization
If you want several major modes to share the same set of history and backends (like ~lisp-interaction-mode~ and ~emacs-lisp-mode~), add an entry ~(mode1 . mode2)~ to ~ghelp-mode-share-alist~, and ~mode1~ will share everything of ~mode2~.

You can customize faces: ~ghelp-entry~, ~ghelp-folded-entry~, and ~ghelp-entry-title~.

Normally if you call ~ghelp-describe-function~ it selects the backends to use by the current major-mode. If you want to look up some symbol with a specific backend, try ~(ghelp-describe-as-in 'mode)~. For example, you can bind
#+BEGIN_SRC emacs-lisp
(define-key (kbd "C-h C-e") (lambda () (interactive) (ghelp-describe-as-in ’emacs-lisp-mode)))
#+END_SRC
to look up Emacs Lisp symbols regardless of which major mode you are currently in.

* Write a backend
A backend is a function that gets the symbol, find the documentation and return them to ghelp.

The backend function should look like this:

#+begin_src emacs-lisp
(defun my-backend (&optional prompt data &rest _)
  (let* ((symbol (or (plist-get data :symbol)
                     (ghelp-maybe-prompt prompt (symbol-name
                                                 (symbol-at-point))
                       (completing-read "Symbol: " '("A" "B" "C")))))
         (doc (get-documentation symbol)))
    (symbol (("Entry 1" "Documentation body")
             ("Entry 2" "Documentation body")))))
#+end_src

~DATA~ is a plist of form:
#+begin_src emacs-lisp
(:symbol SYMBOL :marker MARKER)
#+end_src
~SYMBOL~ is either ~nil~ or a string. If ~SYMBOL~ is ~non-nil~, then it is the symbol we want documentation for. If ~SYMBOL~ is ~nil~, you should get the symbol from the user. ~MARKER~ is the point marker at where the user requested for documentation.

1. Resolve symbol. If ~SYMBOL~ is ~non-nil~, just use it. If it is ~nil~, you need to either guess for one or prompt the user to type in the symbol. ~PROMPT~ represents the prompting strategy, there are three strategies:
- ~'no-prompt~: Never prompt user. We guess the symbol or fail.
- ~'force-prompt~: Must prompt user.
- ~nil~: If we can guess the symbol, don’t show prompt, if not, prompt for a symbol.

You can guess the symbol by 
#+begin_src emacs-lisp
(save-excursion
  (goto-char (plist-get data :marker))
  (symbol-name (symbol-at-point)))
#+end_src
and prompt for a symbol by ~completing-read~. Ghelp provides a helpful macro ~ghelp-maybe-prompt~ to handle ~PROMPT~ for you (as shown in the example).

The return values is ~(SYMBOL ((TITLE BODY) ...))~. SYMBOL is just the symbol (again, a string). ~TITLE~ is the title of the documentation, ~BODY~ is documentation body (has to end with newline). You can have multiple documentations if you wish. Maybe the symbol can mean multiple things. In Emacs Lisp, a symbol can be a function, a variable, a face, etc, at the same time.

Below is an example backend that gets the symbol and then the documentation and returns them. It only recognizes “woome”, “veemo”, “love” and “many”.
#+BEGIN_SRC emacs-lisp
(defun ghelp-dummy-backend (&optional prompt data)
  "Demo. Prompt behavior depends on PROMPT.

DATA is a plist of form 

    (:symbol SYMBOL :marker MARKER)

SYMBOL is either nil or a string. If SYMBOL is non-nil, then it
is the symbol we want documentation for. If SYMBOL is nil, we
should get the symbol from the user ourselves. MARKER is
the point marker at where the user requested for documentation.

Return (SYMBOL ENTRY-LIST), where SYMBOL
is a string, and ENTRY-LIST is a list (ENTRY ...), where each
ENTRY is (TITLE DOC)."
  (let* ((default-symbol (symbol-name (symbol-at-point)))
         (symbol (or (plist-get data :symbol)
                     (ghelp-maybe-prompt prompt default-symbol
                       (ghelp-completing-read ; I can also use ‘completing-read’
                        default-symbol
                        '("woome" "veemo" "love" "and" "peace" "many")))))
         ;; get documentation
         ;; note that title doesn’t need ending newline but doc does
         (entry-list (pcase symbol
                       ;;           title   documentation
                       ("woome" '(("Woome"  "Woome!\n")))
                       ("veemo" '(("Veemo"  "Veemo!\n")))
                       ("love"  '(("Love"   "Love is good.\n")))
                       ;; multiple entries
                       ("many"  '(("Many1"  "I’m ONE.\n") ("Many2" "I’m TWO.\n"))))))
    (list symbol entry-list)))
#+END_SRC

Register your backend by
#+BEGIN_SRC emacs-lisp
(ghelp-register-backend 'major-mode #'your-backend-function)
#+END_SRC

* Screencasts
*Eglot*

[[./ghelp-eglot-800.gif]]

*Helpful*

[[./ghelp-helpful-800.gif]]
